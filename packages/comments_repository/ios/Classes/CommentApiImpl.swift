import Foundation
import Flutter

/// Implementation of the CommentApi protocol generated by Pigeon.
///
/// This implementation stores a base URL configuration (scheme, authority, and port)
/// provided by the Dart side via `setBaseUrl(_:_:)` and then uses that configuration
/// to construct the URL for fetching comments for a specific post.
class CommentApiImpl: NSObject, CommentApi {
  
  // MARK: - Configuration Properties
  
  /// The URL scheme (e.g. "https").
  var scheme: String = "https"
  
  /// The URL authority/host (e.g. "jsonplaceholder.typicode.com").
  var authority: String = "jsonplaceholder.typicode.com"
  
  /// The URL port (e.g. 443). Typically 443 for HTTPS and 80 for HTTP.
  var port: Int = 443

  // MARK: - Pigeon API Methods

  /// Sets the base URL configuration.
  ///
  /// - Parameters:
  ///   - scheme: The URL scheme.
  ///   - authority: The host name.
  ///   - port: The port number, passed as an NSNumber.
  func setBaseUrl(scheme: String, authority: String, port: Int64) {
    self.scheme = scheme
    self.authority = authority
    self.port = Int(port)
  }

  /// Synchronously fetches a list of CommentModel objects for the given postId.
  ///
  /// If this method is called on the main thread, it dispatches the network work to a background
  /// queue to avoid stuttering the UI.
  ///
  /// - Parameter postId: The ID of the post whose comments should be fetched, passed as an NSNumber.
  /// - Returns: An array of CommentModel objects.
  /// - Throws: An error if the network call or JSON parsing fails.
  func getComments(postId: Int64) throws -> [CommentModel] {
    if Thread.isMainThread {
      // If on the main thread, dispatch the blocking network call to a background queue.
      return try DispatchQueue.global(qos: .userInitiated).sync {
        return try self.getCommentsBlocking(postId: postId)
      }
    } else {
      // If not on the main thread, perform the network call directly.
      return try self.getCommentsBlocking(postId: postId)
    }
  }

  /// Helper method that contains the semaphoreâ€‘based network call logic.
  ///
  /// This method builds the URL, performs the URLSession data task, and waits for the result.
  ///
  /// - Parameter postId: The post ID as an NSNumber.
  /// - Returns: An array of CommentModel objects.
  /// - Throws: An error if the network call or JSON parsing fails.
  private func getCommentsBlocking(postId: Int64) throws -> [CommentModel] {
    // Build the URL string using the stored configuration.
    let urlString: String
    if (scheme == "http" && port == 80) || (scheme == "https" && port == 443) {
      urlString = "\(scheme)://\(authority)/comments?postId=\(postId)"
    } else {
      urlString = "\(scheme)://\(authority):\(port)/comments?postId=\(postId)"
    }
    
    guard let url = URL(string: urlString) else {
      throw NSError(
        domain: "CommentApiImpl",
        code: 0,
        userInfo: [NSLocalizedDescriptionKey: "Invalid URL: \(urlString)"]
      )
    }
    
    // Use a semaphore to wait until the asynchronous network call completes.
    let semaphore = DispatchSemaphore(value: 0)
    var fetchedComments: [CommentModel] = []
    var requestError: Error?
    
    let task: URLSessionDataTask = URLSession.shared.dataTask(with: url, completionHandler: { (data: Data?, response: URLResponse?, error: Error?) -> Void in
      defer { semaphore.signal() }
      
      if let error = error {
        requestError = error
        return
      }
      
      guard let data = data else {
        requestError = NSError(
          domain: "CommentApiImpl",
          code: 0,
          userInfo: [NSLocalizedDescriptionKey: "No data received"]
        )
        return
      }
      
      do {
        // Parse the JSON response into an array of dictionaries.
        if let jsonArray = try JSONSerialization.jsonObject(with: data, options: []) as? [[String: Any]] {
          var comments: [CommentModel] = []
          for dict in jsonArray {
            // Extract and convert fields from the JSON dictionary.
            let postIdNumber = dict["postId"] as? NSNumber
            let idNumber = dict["id"] as? NSNumber
            let nameValue = dict["name"] as? String
            let emailValue = dict["email"] as? String
            let bodyValue = dict["body"] as? String
            
            let comment = CommentModel(
              postId: postIdNumber?.int64Value,
              id: idNumber?.int64Value,
              name: nameValue,
              email: emailValue,
              body: bodyValue
            )
            comments.append(comment)
          }
          fetchedComments = comments
        } else {
          requestError = NSError(
            domain: "CommentApiImpl",
            code: 0,
            userInfo: [NSLocalizedDescriptionKey: "Invalid JSON format"]
          )
        }
      } catch {
        requestError = error
      }
    })
    
    task.resume()
    semaphore.wait()
    
    if let error = requestError {
      throw error
    }
    return fetchedComments
  }
}
